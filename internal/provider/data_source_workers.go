// Code generated by "make datasources"; DO NOT EDIT.
// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"net/url"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

var dataSourceWorkersSchema = map[string]*schema.Schema{
	"filter": {
		Type:     schema.TypeString,
		Optional: true,
	},
	"items": {
		Type:     schema.TypeList,
		Computed: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"active_connection_count": {
					Type:        schema.TypeInt,
					Computed:    true,
					Description: "Output only. The number of connections that this worker is currently handling.",
				},
				"address": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The address that this worker is reachable at, as sourced from\nthe worker's configuration file.",
				},
				"authorized_actions": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The available actions on this resource for the requester.",
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"controller_generated_activation_token": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. An activation token that can be given to a worker to correlate\nit to the created resource.",
				},
				"created_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The time this resource was created.",
				},
				"description": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Optional user-set description for identification purposes. Can only be set\nthrough the API for `pki`-type workers; read-only for `kms`-type workers.",
				},
				"directly_connected_downstream_workers": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The ids of the workers directly connected to this worker.",
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The ID of the User.",
				},
				"last_status_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The time this worker daemon last reported its status.",
				},
				"local_storage_state": {
					Type:     schema.TypeString,
					Computed: true,
				},
				"name": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Optional name for identification purposes. Can only be set through the API\nfor `pki`-type workers; read-only for `kms`-type workers.",
				},
				"release_version": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The version of the Boundary binary the worker is running.",
				},
				"scope": {
					Type:     schema.TypeList,
					Computed: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"description": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The description of the scope, if any.",
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the scope.",
							},
							"name": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The name of the scope, if any.",
							},
							"parent_scope_id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the parent scope, if any. This field is empty if it is the \"global\" scope.",
							},
							"type": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The type of the scope.",
							},
						},
					},
				},
				"scope_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The ID of the Scope this resource is in.",
				},
				"type": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The type of the worker, denoted by how it authenticates: `pki`\nor `kms`.",
				},
				"updated_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The time this resource was last updated.",
				},
				"version": {
					Type:        schema.TypeInt,
					Computed:    true,
					Description: "Version is used in mutation requests, after the initial creation, to ensure this resource has not changed.\nThe mutation will fail if the version does not match the latest known good version.",
				},
				"worker_generated_auth_token": {
					Type:     schema.TypeString,
					Computed: true,
				},
			},
		},
	},
	"recursive": {
		Type:     schema.TypeBool,
		Optional: true,
	},
	"scope_id": {
		Type:     schema.TypeString,
		Optional: true,
	},
}

func dataSourceWorkers() *schema.Resource {
	return &schema.Resource{
		Description: "Lists workers",
		ReadContext: dataSourceWorkersRead,
		Schema:      dataSourceWorkersSchema,
	}
}

func dataSourceWorkersRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*metaData).client

	req, err := client.NewRequest(ctx, "GET", "workers", nil)
	if err != nil {
		return diag.FromErr(err)
	}

	q := url.Values{}
	q.Add("filter", d.Get("filter").(string))
	recursive := d.Get("recursive").(bool)
	if recursive {
		q.Add("recursive", strconv.FormatBool(recursive))
	}
	if d.Get("scope_id") != "" {
		q.Add("scope_id", d.Get("scope_id").(string))
	}
	req.URL.RawQuery = q.Encode()

	resp, err := client.Do(req)
	if err != nil {
		diag.FromErr(err)
	}
	apiError, err := resp.Decode(nil)
	if err != nil {
		return diag.FromErr(err)
	}
	if apiError != nil {
		return apiErr(apiError)
	}
	err = set(dataSourceWorkersSchema, d, resp.Map)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId("boundary-workers")

	return nil
}
