// Code generated by scripts/generate_datasource.go. DO NOT EDIT.
//go:generate go run ../../scripts/generate_datasource.go -name Sessions -path sessions

// This file was generated based on Boundary v0.6.1

package provider

import (
	"context"
	"net/url"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

var dataSourceSessionsSchema = map[string]*schema.Schema{
	"filter": {
		Type:     schema.TypeString,
		Optional: true,
	},
	"items": {
		Type:     schema.TypeList,
		Computed: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"auth_token_id": {
					Type:        schema.TypeString,
					Description: "Output only. The ID of the Auth Token used to authenticate.",
					Computed:    true,
				},
				"authorized_actions": {
					Type:        schema.TypeList,
					Description: "Output only. The available actions on this resource for this user.",
					Computed:    true,
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"certificate": {
					Type:        schema.TypeString,
					Description: "Output only. The certificate generated for the session. Raw DER bytes.",
					Computed:    true,
				},
				"created_time": {
					Type:        schema.TypeString,
					Description: "Output only. The time this resource was created.",
					Computed:    true,
				},
				"endpoint": {
					Type:        schema.TypeString,
					Description: "Output only. The endpoint of the Session; that is, the address to which the worker is proxying data.",
					Computed:    true,
				},
				"expiration_time": {
					Type:        schema.TypeString,
					Description: "Output only. After this time the connection will be expired, e.g. forcefully terminated.",
					Computed:    true,
				},
				"host_id": {
					Type:        schema.TypeString,
					Description: "Output only. The Host used by the Session.",
					Computed:    true,
				},
				"host_set_id": {
					Type:        schema.TypeString,
					Description: "Output only. The Host Set sourcing the Host for this Session.",
					Computed:    true,
				},
				"id": {
					Type:        schema.TypeString,
					Description: "Output only. The ID of the Session.",
					Computed:    true,
				},
				"scope": {
					Type:     schema.TypeList,
					Computed: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"description": {
								Type:        schema.TypeString,
								Description: "Output only. The description of the Scope, if any.",
								Computed:    true,
							},
							"id": {
								Type:        schema.TypeString,
								Description: "Output only. The ID of the Scope.",
								Computed:    true,
							},
							"name": {
								Type:        schema.TypeString,
								Description: "Output only. The name of the Scope, if any.",
								Computed:    true,
							},
							"parent_scope_id": {
								Type:        schema.TypeString,
								Description: "Output only. The ID of the parent Scope, if any. This field will be empty if this is the \"global\" scope.",
								Computed:    true,
							},
							"type": {
								Type:        schema.TypeString,
								Description: "Output only. The type of the Scope.",
								Computed:    true,
							},
						},
					},
				},
				"scope_id": {
					Type:        schema.TypeString,
					Description: "Output only. The Scope of the Session.",
					Computed:    true,
				},
				"states": {
					Type:        schema.TypeList,
					Description: "Output only. The states of this Session in descending order from the current state to the first.",
					Computed:    true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"end_time": {
								Type:        schema.TypeString,
								Description: "Output only. The time the Session stopped being in this state.",
								Computed:    true,
							},
							"start_time": {
								Type:        schema.TypeString,
								Description: "Output only. The time the Session entered this state.",
								Computed:    true,
							},
							"status": {
								Type:        schema.TypeString,
								Description: "The status of the Session, e.g. \"pending\", \"active\", \"canceling\", \"terminated\".",
								Computed:    true,
							},
						},
					},
				},
				"status": {
					Type:        schema.TypeString,
					Description: "Output only. The current status of this Session.",
					Computed:    true,
				},
				"target_id": {
					Type:        schema.TypeString,
					Description: "Output only. The ID of the Target that created this Session.",
					Computed:    true,
				},
				"termination_reason": {
					Type:        schema.TypeString,
					Description: "Output only. If the session is terminated, this provides a short description as to why.",
					Computed:    true,
				},
				"type": {
					Type:        schema.TypeString,
					Description: "Output only. Type of the Session (e.g. tcp).",
					Computed:    true,
				},
				"updated_time": {
					Type:        schema.TypeString,
					Description: "Output only. The time this resource was last updated.",
					Computed:    true,
				},
				"user_id": {
					Type:        schema.TypeString,
					Description: "Output only. The ID of the User that requested the Session.",
					Computed:    true,
				},
				"version": {
					Type:        schema.TypeInt,
					Description: "Version is used when canceling this Session to ensure that the operation is acting on a known session state.",
					Computed:    true,
				},
				"worker_info": {
					Type:        schema.TypeList,
					Description: "Output only. Worker information given to the client.",
					Computed:    true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"address": {
								Type:        schema.TypeString,
								Description: "The address of the worker.",
								Computed:    true,
							},
						},
					},
				},
			},
		},
	},
	"recursive": {
		Type:     schema.TypeBool,
		Optional: true,
	},
	"scope_id": {
		Type:     schema.TypeString,
		Optional: true,
	},
}

func dataSourceSessions() *schema.Resource {
	return &schema.Resource{
		Description: "Lists all Sessions.",
		Schema:      dataSourceSessionsSchema,
		ReadContext: dataSourceSessionsRead,
	}
}

func dataSourceSessionsRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*metaData).client

	req, err := client.NewRequest(ctx, "GET", "sessions", nil)
	if err != nil {
		return diag.FromErr(err)
	}

	q := url.Values{}
	q.Add("filter", d.Get("filter").(string))
	recursive := d.Get("recursive").(bool)
	if recursive {
		q.Add("recursive", strconv.FormatBool(recursive))
	}
	q.Add("scope_id", d.Get("scope_id").(string))
	req.URL.RawQuery = q.Encode()

	resp, err := client.Do(req)
	if err != nil {
		diag.FromErr(err)
	}
	apiError, err := resp.Decode(nil)
	if err != nil {
		return diag.FromErr(err)
	}
	if apiError != nil {
		return apiErr(apiError)
	}
	err = set(dataSourceSessionsSchema, d, resp.Map)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId("boundary-sessions")

	return nil
}
