// Code generated by "make datasources"; DO NOT EDIT.
// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"net/url"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

var dataSourceSessionsSchema = map[string]*schema.Schema{
	"est_item_count": {
		Type:        schema.TypeInt,
		Computed:    true,
		Description: "An estimate at the total items available. This may change during pagination.",
	},
	"filter": {
		Type:        schema.TypeString,
		Optional:    true,
		Description: "You can specify that the filter should only return items that match.\nRefer to [filter expressions](https://developer.hashicorp.com/boundary/docs/concepts/filtering) for more information.",
	},
	"include_terminated": {
		Type:        schema.TypeBool,
		Optional:    true,
		Description: "Experimental. By default only non-terminated (i.e. pending, active, canceling) are returned.\nSet this option to include terminated sessions as well.",
	},
	"items": {
		Type:     schema.TypeList,
		Computed: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"auth_token_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The ID of the Auth Token used to authenticate.",
				},
				"authorized_actions": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The available actions on this resource for this user.",
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"certificate": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The certificate generated for the session. Raw DER bytes.",
				},
				"connections": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The associated connections with this session.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"bytes_down": {
								Type:     schema.TypeString,
								Computed: true,
							},
							"bytes_up": {
								Type:     schema.TypeString,
								Computed: true,
							},
							"client_tcp_address": {
								Type:     schema.TypeString,
								Computed: true,
							},
							"client_tcp_port": {
								Type:     schema.TypeInt,
								Computed: true,
							},
							"closed_reason": {
								Type:     schema.TypeString,
								Computed: true,
							},
							"endpoint_tcp_address": {
								Type:     schema.TypeString,
								Computed: true,
							},
							"endpoint_tcp_port": {
								Type:     schema.TypeInt,
								Computed: true,
							},
						},
					},
				},
				"created_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The time this resource was created.",
				},
				"endpoint": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The endpoint of the Session; that is, the address to which the worker is proxying data.",
				},
				"expiration_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. After this time the connection will be expired, e.g. forcefully terminated.",
				},
				"host_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The Host used by the Session.",
				},
				"host_set_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The Host Set sourcing the Host for this Session.",
				},
				"id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The ID of the Session.",
				},
				"scope": {
					Type:     schema.TypeList,
					Computed: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"description": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The description of the scope, if any.",
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the scope.",
							},
							"name": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The name of the scope, if any.",
							},
							"parent_scope_id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the parent scope, if any. This field is empty if it is the \"global\" scope.",
							},
							"type": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The type of the scope.",
							},
						},
					},
				},
				"scope_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The Scope of the Session.",
				},
				"states": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The states of this Session in descending order from the current state to the first.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"end_time": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The time the Session stopped being in this state.",
							},
							"start_time": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The time the Session entered this state.",
							},
							"status": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The status of the Session, e.g. \"pending\", \"active\", \"canceling\", \"terminated\".",
							},
						},
					},
				},
				"status": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The current status of this Session.",
				},
				"target_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The ID of the Target that created this Session.",
				},
				"termination_reason": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. If the session is terminated, this provides a short description as to why.",
				},
				"type": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. Type of the Session (e.g. tcp).",
				},
				"updated_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The time this resource was last updated.",
				},
				"user_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The ID of the User that requested the Session.",
				},
				"version": {
					Type:        schema.TypeInt,
					Computed:    true,
					Description: "Version is used when canceling this Session to ensure that the operation is acting on a known session state.",
				},
			},
		},
	},
	"list_token": {
		Type:        schema.TypeString,
		Optional:    true,
		Computed:    true,
		Description: "An opaque token that Boundary uses to continue an existing iteration or\nrequest updated items. If you do not specify a token, pagination\nstarts from the beginning. To learn more about list pagination\nin Boundary, refer to [list pagination](https://developer.hashicorp.com/boundary/docs/api-clients/api/pagination).",
	},
	"page_size": {
		Type:        schema.TypeInt,
		Optional:    true,
		Description: "The maximum size of a page in this iteration.\nIf unset, the default page size configured will be used.\nIf the page_size is greater than the default page configured,\nthe page size will be truncated to this number..",
	},
	"recursive": {
		Type:     schema.TypeBool,
		Optional: true,
	},
	"removed_ids": {
		Type:        schema.TypeList,
		Computed:    true,
		Description: "A list of item IDs that have been removed since they were returned\nas part of a pagination. They should be dropped from any client cache.\nThis may contain items that are not known to the cache, if they were\ncreated and deleted between listings.",
		Elem: &schema.Schema{
			Type: schema.TypeString,
		},
	},
	"response_type": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "The type of response, either \"delta\" or \"complete\".\nDelta signifies that this is part of a paginated result\nor an update to a previously completed pagination.\nComplete signifies that it is the last page.",
	},
	"scope_id": {
		Type:     schema.TypeString,
		Optional: true,
	},
	"sort_by": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "The name of the field which the items are sorted by.",
	},
	"sort_dir": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "The direction of the sort, either \"asc\" or \"desc\".",
	},
}

func dataSourceSessions() *schema.Resource {
	return &schema.Resource{
		Description: "Lists sessions",
		ReadContext: dataSourceSessionsRead,
		Schema:      dataSourceSessionsSchema,
	}
}

func dataSourceSessionsRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*metaData).client

	req, err := client.NewRequest(ctx, "GET", "sessions", nil)
	if err != nil {
		return diag.FromErr(err)
	}

	q := url.Values{}
	q.Add("filter", d.Get("filter").(string))
	include_terminated := d.Get("include_terminated").(bool)
	if include_terminated {
		q.Add("include_terminated", strconv.FormatBool(include_terminated))
	}
	q.Add("list_token", d.Get("list_token").(string))
	if d.Get("scope_id") != 0 {
		q.Add("page_size", strconv.Itoa(d.Get("page_size").(int)))
	}
	recursive := d.Get("recursive").(bool)
	if recursive {
		q.Add("recursive", strconv.FormatBool(recursive))
	}
	if d.Get("scope_id") != "" {
		q.Add("scope_id", d.Get("scope_id").(string))
	}
	req.URL.RawQuery = q.Encode()

	resp, err := client.Do(req)
	if err != nil {
		diag.FromErr(err)
	}
	apiError, err := resp.Decode(nil)
	if err != nil {
		return diag.FromErr(err)
	}
	if apiError != nil {
		return apiErr(apiError)
	}
	err = set(dataSourceSessionsSchema, d, resp.Map)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId("boundary-sessions")

	return nil
}
