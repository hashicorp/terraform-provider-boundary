// Code generated by "make datasources"; DO NOT EDIT.
// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"net/url"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

var dataSourceSessionRecordingsSchema = map[string]*schema.Schema{
	"est_item_count": {
		Type:        schema.TypeInt,
		Computed:    true,
		Description: "An estimate at the total items available. This may change during pagination.",
	},
	"items": {
		Type:        schema.TypeList,
		Computed:    true,
		Description: "The items returned in this page.",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"authorized_actions": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "The available actions on this resource for this user.",
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"bytes_down": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The total number of bytes downloaded to the client in the Session.\nThis includes all bytes downloaded over all Connections, including\nany protocol overhead.",
				},
				"bytes_up": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The total number of bytes uploaded from the client in the Session.\nThis includes all bytes uploaded over all Connections, including\nany protocol overhead.",
				},
				"connection_recordings": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "The recordings of the connections that were created in the Session.\nThis field may be unset when listing Session recordings.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"bytes_down": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The total number of bytes downloaded to the client in the Connection.\nThis includes any protocol overhead.",
							},
							"bytes_up": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The total number of bytes uploaded from the client in the Connection.\nThis includes any protocol overhead.",
							},
							"channel_recordings": {
								Type:        schema.TypeList,
								Computed:    true,
								Description: "Optionally, the channels used in this Connection,\nif it is using a multiplexed protocol, such as SSH.",
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"bytes_down": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The total number of bytes downloaded to the client in the Channel.",
										},
										"bytes_up": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The total number of bytes uploaded from the client in the Channel.",
										},
										"created_time": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The time the Channel was created in the controller.",
										},
										"duration": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The total duration of the Channel.",
										},
										"end_time": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The time the Channel ended.",
										},
										"id": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The ID of the Channel recording.",
										},
										"mime_types": {
											Type:        schema.TypeList,
											Computed:    true,
											Description: "MimeTypes define the mime types that can\nbe used to consume the recording of this Channel.\nThe only supported mime type is \"application/x-asciicast\".",
											Elem: &schema.Schema{
												Type: schema.TypeString,
											},
										},
										"start_time": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The time the Channel started.",
										},
										"updated_time": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The time of the most recent update to the Channel.",
										},
									},
								},
							},
							"created_time": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The time the Connection was created in the controller.",
							},
							"duration": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The total duration of the Connection.",
							},
							"end_time": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The time the Connection ended.",
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the Connection recording.",
							},
							"mime_types": {
								Type:        schema.TypeList,
								Computed:    true,
								Description: "MimeTypes define the mime types that can\nbe used to consume the recording of this Connection.\nNo mime types are currently supported.",
								Elem: &schema.Schema{
									Type: schema.TypeString,
								},
							},
							"start_time": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The time the Connection started.",
							},
							"updated_time": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The time of the most recent update to the Connection.",
							},
						},
					},
				},
				"create_time_values": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "ValuesAtTime contain information about other Boundary resources as they\nwere at a certain time through the lifetime of the Session Recording.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"credential_libraries": {
								Type:        schema.TypeList,
								Computed:    true,
								Description: "Information about the Credential Libraries used for this session.",
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"credential_store": {
											Type:     schema.TypeList,
											Computed: true,
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													"description": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The description for identification purposes if set.",
													},
													"id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The ID of the Credential Store.",
													},
													"name": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The name for identification purposes if set.",
													},
													"scope_id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The ID of the Scope of which this Credential Store is a part.",
													},
													"type": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The Credential Store type.",
													},
												},
											},
										},
										"description": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "Optional user-set description of this Credential Library.",
										},
										"id": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The ID of the Credential Library.",
										},
										"name": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "Optional name of this Credential Library.",
										},
										"purposes": {
											Type:        schema.TypeList,
											Computed:    true,
											Description: "The purposes for which this CredentialLibrary was attached to the sesssion.",
											Elem: &schema.Schema{
												Type: schema.TypeString,
											},
										},
										"type": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The Credential Library type.",
										},
									},
								},
							},
							"credentials": {
								Type:        schema.TypeList,
								Computed:    true,
								Description: "Information about the Credentials used for this session.",
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"credential_store": {
											Type:     schema.TypeList,
											Computed: true,
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													"description": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The description for identification purposes if set.",
													},
													"id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The ID of the Credential Store.",
													},
													"name": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The name for identification purposes if set.",
													},
													"scope_id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The ID of the Scope of which this Credential Store is a part.",
													},
													"type": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The Credential Store type.",
													},
												},
											},
										},
										"description": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "Optional user-set description.",
										},
										"id": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The ID of the Credential.",
										},
										"name": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The name of the credential.",
										},
										"purposes": {
											Type:        schema.TypeList,
											Computed:    true,
											Description: "The purposes for which this Credential was attached to the sesssion.",
											Elem: &schema.Schema{
												Type: schema.TypeString,
											},
										},
										"type": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The Credential type.",
										},
									},
								},
							},
							"host": {
								Type:        schema.TypeList,
								Computed:    true,
								Description: "Host describes the Host that was chosen for the recorded session.",
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"description": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The description of the Host, if set.",
										},
										"external_id": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The external id of the Host, if any.",
										},
										"external_name": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The external name of the Host, if any.",
										},
										"host_catalog": {
											Type:        schema.TypeList,
											Computed:    true,
											Description: "HostCatalog describes the HostCatalog that contains the host chosen for the\nrecorded session.",
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													"description": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The description of the Host Catalog.",
													},
													"id": {
														Type:     schema.TypeString,
														Computed: true,
													},
													"name": {
														Type:     schema.TypeString,
														Computed: true,
													},
													"plugin_id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The plugin id used by this Host Catalog, if any.",
													},
													"scope": {
														Type:     schema.TypeList,
														Computed: true,
														Elem: &schema.Resource{
															Schema: map[string]*schema.Schema{
																"description": {
																	Type:        schema.TypeString,
																	Computed:    true,
																	Description: "The description of the scope, if any.",
																},
																"id": {
																	Type:        schema.TypeString,
																	Computed:    true,
																	Description: "The ID of the scope.",
																},
																"name": {
																	Type:        schema.TypeString,
																	Computed:    true,
																	Description: "The name of the scope, if any.",
																},
																"parent_scope_id": {
																	Type:        schema.TypeString,
																	Computed:    true,
																	Description: "The ID of the parent scope, if any. This field is empty if it is the \"global\" scope.",
																},
																"type": {
																	Type:        schema.TypeString,
																	Computed:    true,
																	Description: "The type of the scope.",
																},
															},
														},
													},
													"type": {
														Type:     schema.TypeString,
														Computed: true,
													},
												},
											},
										},
										"id": {
											Type:     schema.TypeString,
											Computed: true,
										},
										"name": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The name of the Host, if set.",
										},
										"type": {
											Type:     schema.TypeString,
											Computed: true,
										},
									},
								},
							},
							"target": {
								Type:        schema.TypeList,
								Computed:    true,
								Description: "Target describes a target in Boundary.",
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"description": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The description of the Target, if set.",
										},
										"egress_worker_filter": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "Optional boolean expressions to filter the egress workers that are allowed to satisfy this request.",
										},
										"id": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The ID of the Target.",
										},
										"ingress_worker_filter": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "Optional boolean expressions to filter the ingress workers that are allowed to satisfy this request.",
										},
										"name": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The name of the Target, if set.",
										},
										"scope": {
											Type:     schema.TypeList,
											Computed: true,
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													"description": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The description of the scope, if any.",
													},
													"id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The ID of the scope.",
													},
													"name": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The name of the scope, if any.",
													},
													"parent_scope_id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The ID of the parent scope, if any. This field is empty if it is the \"global\" scope.",
													},
													"type": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The type of the scope.",
													},
												},
											},
										},
										"session_connection_limit": {
											Type:        schema.TypeInt,
											Computed:    true,
											Description: "Maximum number of connections allowed in a Session.  Unlimited is indicated by the value -1.",
										},
										"session_max_seconds": {
											Type:        schema.TypeInt,
											Computed:    true,
											Description: "Maximum total lifetime of a created Session, in seconds.",
										},
										"type": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The type of the Target.",
										},
										"worker_filter": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "Optional boolean expression to filter the workers that are allowed to satisfy this request.",
										},
									},
								},
							},
							"user": {
								Type:        schema.TypeList,
								Computed:    true,
								Description: "User describes an authenticated user in Boundary.",
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"description": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The description of the User that created the Session.",
										},
										"id": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The ID of the User.",
										},
										"name": {
											Type:        schema.TypeString,
											Computed:    true,
											Description: "The name of the User that created the Session.",
										},
										"scope": {
											Type:     schema.TypeList,
											Computed: true,
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													"description": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The description of the scope, if any.",
													},
													"id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The ID of the scope.",
													},
													"name": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The name of the scope, if any.",
													},
													"parent_scope_id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The ID of the parent scope, if any. This field is empty if it is the \"global\" scope.",
													},
													"type": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "The type of the scope.",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				"created_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The time the Session Recording was created in the controller.",
				},
				"delete_after": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The time a session recording is scheduled to be automatically deleted.",
				},
				"duration": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The total duration of the Session.",
				},
				"end_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The time the Session ended.",
				},
				"endpoint": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The endpoint of the Session; that is, the address to which the egress worker connected.",
				},
				"error_details": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Any error seen during the closing of the session recording.\nCurrently only set if state is \"unknown\".",
				},
				"id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The ID of the Session recording.",
				},
				"mime_types": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "MimeTypes define the mime types that can\nbe used to consume the recording of this Session.\nNo mime types are currently supported.",
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"retain_until": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The time until a session recording is required to be stored.",
				},
				"scope": {
					Type:     schema.TypeList,
					Computed: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"description": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The description of the scope, if any.",
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the scope.",
							},
							"name": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The name of the scope, if any.",
							},
							"parent_scope_id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the parent scope, if any. This field is empty if it is the \"global\" scope.",
							},
							"type": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The type of the scope.",
							},
						},
					},
				},
				"session_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The ID of the Session which this Session Recording recorded.",
				},
				"start_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The time the Session started.",
				},
				"state": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The current state of the session recording. One of\n\"started\", \"available\" and \"unknown\".",
				},
				"storage_bucket_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The ID of the Storage Bucket for the Target of this Session Recording.",
				},
				"type": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Type of the Session that was recorded (e.g. ssh).",
				},
				"updated_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The time of the most recent update to the Session Recording.",
				},
			},
		},
	},
	"list_token": {
		Type:        schema.TypeString,
		Optional:    true,
		Computed:    true,
		Description: "An opaque token that Boundary uses to continue an existing iteration or\nrequest updated items. If you do not specify a token, pagination\nstarts from the beginning. To learn more about list pagination\nin Boundary, refer to [list pagination](https://developer.hashicorp.com/boundary/docs/api-clients/api/pagination).",
	},
	"page_size": {
		Type:        schema.TypeInt,
		Optional:    true,
		Description: "The maximum size of a page in this iteration.\nIf you do not set a page size, Boundary uses the configured default page size.\nIf the page_size is greater than the default page size configured,\nBoundary truncates the page size to this number.",
	},
	"recursive": {
		Type:        schema.TypeBool,
		Optional:    true,
		Description: "Whether to recurse into child scopes when listing.\nIf set and scope_id is empty, shows session recordings in\nall scopes the caller has access to.",
	},
	"removed_ids": {
		Type:        schema.TypeList,
		Computed:    true,
		Description: "A list of item IDs that have been removed since they were returned\nas part of a pagination. They should be dropped from any client cache.\nThis may contain items that are not known to the cache, if they were\ncreated and deleted between listings.",
		Elem: &schema.Schema{
			Type: schema.TypeString,
		},
	},
	"response_type": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "The type of response, either \"delta\" or \"complete\".\nDelta signifies that this is part of a paginated result\nor an update to a previously completed pagination.\nComplete signifies that it is the last page.",
	},
	"scope_id": {
		Type:        schema.TypeString,
		Optional:    true,
		Description: "The scope in which to list session recordings.\nMust be set unless recursive is set.",
	},
	"sort_by": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "The name of the field which the items are sorted by.",
	},
	"sort_dir": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "The direction of the sort, either \"asc\" or \"desc\".",
	},
}

func dataSourceSessionRecordings() *schema.Resource {
	return &schema.Resource{
		Description: "Lists session-recordings",
		ReadContext: dataSourceSessionRecordingsRead,
		Schema:      dataSourceSessionRecordingsSchema,
	}
}

func dataSourceSessionRecordingsRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*metaData).client

	req, err := client.NewRequest(ctx, "GET", "session-recordings", nil)
	if err != nil {
		return diag.FromErr(err)
	}

	q := url.Values{}
	q.Add("list_token", d.Get("list_token").(string))
	if d.Get("") != 0 {
		q.Add("page_size", strconv.Itoa(d.Get("page_size").(int)))
	}
	recursive := d.Get("recursive").(bool)
	if recursive {
		q.Add("recursive", strconv.FormatBool(recursive))
	}
	q.Add("scope_id", d.Get("scope_id").(string))
	req.URL.RawQuery = q.Encode()

	resp, err := client.Do(req)
	if err != nil {
		diag.FromErr(err)
	}
	apiError, err := resp.Decode(nil)
	if err != nil {
		return diag.FromErr(err)
	}
	if apiError != nil {
		return apiErr(apiError)
	}
	err = set(dataSourceSessionRecordingsSchema, d, resp.Map)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId("boundary-session-recordings")

	return nil
}
