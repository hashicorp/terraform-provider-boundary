// Code generated by "make datasources"; DO NOT EDIT.
// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"net/url"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

var dataSourceTargetsSchema = map[string]*schema.Schema{
	"est_item_count": {
		Type:        schema.TypeInt,
		Computed:    true,
		Description: "An estimate at the total items available. This may change during pagination.",
	},
	"filter": {
		Type:        schema.TypeString,
		Optional:    true,
		Description: "You can specify that the filter should only return items that match.\nRefer to [filter expressions](https://developer.hashicorp.com/boundary/docs/concepts/filtering) for more information.",
	},
	"items": {
		Type:     schema.TypeList,
		Computed: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"address": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Optional string value that represents a network resource and is used when establishing a session.",
				},
				"aliases": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The aliases that point to this Target.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"attributes": {
								Type:     schema.TypeList,
								Computed: true,
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"authorize_session_arguments": {
											Type:     schema.TypeList,
											Computed: true,
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													"host_id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "host_id is the id of the host that the session will be authorized for.\nWhen specified authorizing a session using this alias will have the same\neffect of authorizing a session to the alias' destination_id and passing\nin this value through the -host-id flag. If the host-id flag is also\nspecified when calling authorize-session an error will be returned unless\nthe provided host-id matches this value.",
													},
												},
											},
										},
									},
								},
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The ID of the alias referencing this target.",
							},
							"scope_id": {
								Type:     schema.TypeString,
								Computed: true,
							},
							"value": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Ouput only. The value of the alias referencing this target.",
							},
						},
					},
				},
				"authorized_actions": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The available actions on this resource for this user.",
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"brokered_credential_source_ids": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The IDs of the brokered credential source ids associated with this Target.",
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"brokered_credential_sources": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The brokered credential sources associated with this Target.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"credential_store_id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The Credential Store to which this Credential source belongs.",
							},
							"credential_type": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The type of the credential, empty if unspecified.",
							},
							"description": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The description of the Credential source.",
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the Credential. May be empty if the credential is dynamically generated from a library.",
							},
							"name": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The name of the Credential source.",
							},
							"type": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The type of the credential source (e.g. \"vault\"; not the type of the credential itself).",
							},
						},
					},
				},
				"created_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The time this resource was created.",
				},
				"description": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Optional user-set description for identification purposes.",
				},
				"egress_worker_filter": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Optional boolean expressions to filter the egress workers that are allowed to satisfy this request.",
				},
				"host_source_ids": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The IDs of the Host Sources associated with this Target.",
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"host_sources": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The Host Sources associated with this Target.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"host_catalog_id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The Host Catalog to which this Host Source belongs.",
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The ID of the Host Set.",
							},
						},
					},
				},
				"id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The ID of the resource.",
				},
				"ingress_worker_filter": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Optional boolean expressions to filter the ingress workers that are allowed to satisfy this request.\nUnsupported on OSS.",
				},
				"injected_application_credential_source_ids": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The IDs of the injected application credential source ids associated with this Target.",
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"injected_application_credential_sources": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Output only. The injected application credential sources associated with this Target.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"credential_store_id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The Credential Store to which this Credential source belongs.",
							},
							"credential_type": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The type of the credential, empty if unspecified.",
							},
							"description": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The description of the Credential source.",
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the Credential. May be empty if the credential is dynamically generated from a library.",
							},
							"name": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The name of the Credential source.",
							},
							"type": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The type of the credential source (e.g. \"vault\"; not the type of the credential itself).",
							},
						},
					},
				},
				"name": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Required name for identification purposes.",
				},
				"scope": {
					Type:     schema.TypeList,
					Computed: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"description": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The description of the scope, if any.",
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the scope.",
							},
							"name": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The name of the scope, if any.",
							},
							"parent_scope_id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The ID of the parent scope, if any. This field is empty if it is the \"global\" scope.",
							},
							"type": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "The type of the scope.",
							},
						},
					},
				},
				"scope_id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The Scope of of this resource. This must be defined for creation of this resource, but is otherwise output only.",
				},
				"session_connection_limit": {
					Type:        schema.TypeInt,
					Computed:    true,
					Description: "Maximum number of connections allowed in a Session.  Unlimited is indicated by the value -1.",
				},
				"session_max_seconds": {
					Type:        schema.TypeInt,
					Computed:    true,
					Description: "Maximum total lifetime of a created Session, in seconds.",
				},
				"type": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "The type of the Target.",
				},
				"updated_time": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Output only. The time this resource was last updated.",
				},
				"version": {
					Type:        schema.TypeInt,
					Computed:    true,
					Description: "Version is used in mutation requests, after the initial creation, to ensure this resource has not changed.\nThe mutation will fail if the version does not match the latest known good version.",
				},
				"with_aliases": {
					Type:        schema.TypeList,
					Computed:    true,
					Description: "Input only. with_aliases specify the aliases that should be created when\nthe target is created.  This field is only usable at target creation time.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"attributes": {
								Type:     schema.TypeList,
								Computed: true,
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"authorize_session_arguments": {
											Type:     schema.TypeList,
											Computed: true,
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													"host_id": {
														Type:        schema.TypeString,
														Computed:    true,
														Description: "host_id is the id of the host that the session will be authorized for.\nWhen specified authorizing a session using this alias will have the same\neffect of authorizing a session to the alias' destination_id and passing\nin this value through the -host-id flag. If the host-id flag is also\nspecified when calling authorize-session an error will be returned unless\nthe provided host-id matches this value.",
													},
												},
											},
										},
									},
								},
							},
							"id": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Output only. The ID of the alias referencing this target.",
							},
							"scope_id": {
								Type:     schema.TypeString,
								Computed: true,
							},
							"value": {
								Type:        schema.TypeString,
								Computed:    true,
								Description: "Ouput only. The value of the alias referencing this target.",
							},
						},
					},
				},
				"worker_filter": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Optional boolean expression to filter the workers that are allowed to satisfy this request.\nDeprecated; use egress or ingress worker filters instead.",
				},
			},
		},
	},
	"list_token": {
		Type:        schema.TypeString,
		Optional:    true,
		Computed:    true,
		Description: "An opaque token that Boundary uses to continue an existing iteration or\nrequest updated items. If you do not specify a token, pagination\nstarts from the beginning. To learn more about list pagination\nin Boundary, refer to [list pagination](https://developer.hashicorp.com/boundary/docs/api-clients/api/pagination).",
	},
	"page_size": {
		Type:        schema.TypeInt,
		Optional:    true,
		Description: "The maximum size of a page in this iteration.\nIf unset, the default page size configured will be used.\nIf the page_size is greater than the default page configured,\nthe page size will be truncated to this number..",
	},
	"recursive": {
		Type:     schema.TypeBool,
		Optional: true,
	},
	"removed_ids": {
		Type:        schema.TypeList,
		Computed:    true,
		Description: "A list of item IDs that have been removed since they were returned\nas part of a pagination. They should be dropped from any client cache.\nThis may contain items that are not known to the cache, if they were\ncreated and deleted between listings.",
		Elem: &schema.Schema{
			Type: schema.TypeString,
		},
	},
	"response_type": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "The type of response, either \"delta\" or \"complete\".\nDelta signifies that this is part of a paginated result\nor an update to a previously completed pagination.\nComplete signifies that it is the last page.",
	},
	"scope_id": {
		Type:     schema.TypeString,
		Optional: true,
	},
	"sort_by": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "The name of the field which the items are sorted by.",
	},
	"sort_dir": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "The direction of the sort, either \"asc\" or \"desc\".",
	},
}

func dataSourceTargets() *schema.Resource {
	return &schema.Resource{
		Description: "Lists targets",
		ReadContext: dataSourceTargetsRead,
		Schema:      dataSourceTargetsSchema,
	}
}

func dataSourceTargetsRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*metaData).client

	req, err := client.NewRequest(ctx, "GET", "targets", nil)
	if err != nil {
		return diag.FromErr(err)
	}

	q := url.Values{}
	q.Add("filter", d.Get("filter").(string))
	q.Add("list_token", d.Get("list_token").(string))
	if d.Get("scope_id") != 0 {
		q.Add("page_size", strconv.Itoa(d.Get("page_size").(int)))
	}
	recursive := d.Get("recursive").(bool)
	if recursive {
		q.Add("recursive", strconv.FormatBool(recursive))
	}
	if d.Get("scope_id") != "" {
		q.Add("scope_id", d.Get("scope_id").(string))
	}
	req.URL.RawQuery = q.Encode()

	resp, err := client.Do(req)
	if err != nil {
		diag.FromErr(err)
	}
	apiError, err := resp.Decode(nil)
	if err != nil {
		return diag.FromErr(err)
	}
	if apiError != nil {
		return apiErr(apiError)
	}
	err = set(dataSourceTargetsSchema, d, resp.Map)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId("boundary-targets")

	return nil
}
