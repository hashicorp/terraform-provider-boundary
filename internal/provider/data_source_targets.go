// Code generated by scripts/generate_datasource.go. DO NOT EDIT.
//go:generate go run ../../scripts/generate_datasource.go -name Targets -path targets

// This file was generated based on Boundary v0.4.0

package provider

import (
	"context"
	"net/url"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

var dataSourceTargetsSchema = map[string]*schema.Schema{
	"filter": {
		Type:     schema.TypeString,
		Optional: true,
	},
	"items": {
		Type:     schema.TypeList,
		Computed: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"application_credential_libraries": {
					Type:        schema.TypeList,
					Description: "Output only. The application credential libraries associated with this Target.",
					Computed:    true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"credential_store_id": {
								Type:        schema.TypeString,
								Description: "Output only. The Credential Store to which this Credential Library belongs.",
								Computed:    true,
							},
							"description": {
								Type:        schema.TypeString,
								Description: "Output only. The description of the Credential Library.",
								Computed:    true,
							},
							"id": {
								Type:        schema.TypeString,
								Description: "The ID of the Credential Library.",
								Computed:    true,
							},
							"name": {
								Type:        schema.TypeString,
								Description: "Output only.  The name of the Credential Library.",
								Computed:    true,
							},
							"type": {
								Type:        schema.TypeString,
								Description: "Output only. The type of the credential library.",
								Computed:    true,
							},
						},
					},
				},
				"application_credential_library_ids": {
					Type:        schema.TypeList,
					Description: "The IDs of the application credential library ids associated with this Target.",
					Computed:    true,
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"authorized_actions": {
					Type:        schema.TypeList,
					Description: "Output only. The available actions on this resource for this user.",
					Computed:    true,
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"created_time": {
					Type:        schema.TypeString,
					Description: "Output only. The time this resource was created.",
					Computed:    true,
				},
				"description": {
					Type:        schema.TypeString,
					Description: "Optional user-set description for identification purposes.",
					Computed:    true,
				},
				"host_set_ids": {
					Type:        schema.TypeList,
					Description: "The IDs of the Host Sets associated with this Target.",
					Computed:    true,
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
				"host_sets": {
					Type:        schema.TypeList,
					Description: "Output only. The Host Sets associated with this Target.",
					Computed:    true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"host_catalog_id": {
								Type:        schema.TypeString,
								Description: "Output only. The Host Catalog to which this Host Set belongs.",
								Computed:    true,
							},
							"id": {
								Type:        schema.TypeString,
								Description: "Output only. The ID of the Host Set.",
								Computed:    true,
							},
						},
					},
				},
				"id": {
					Type:        schema.TypeString,
					Description: "Output only. The ID of the resource.",
					Computed:    true,
				},
				"name": {
					Type:        schema.TypeString,
					Description: "Required name for identification purposes.",
					Computed:    true,
				},
				"scope": {
					Type:     schema.TypeList,
					Computed: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"description": {
								Type:        schema.TypeString,
								Description: "Output only. The description of the Scope, if any.",
								Computed:    true,
							},
							"id": {
								Type:        schema.TypeString,
								Description: "Output only. The ID of the Scope.",
								Computed:    true,
							},
							"name": {
								Type:        schema.TypeString,
								Description: "Output only. The name of the Scope, if any.",
								Computed:    true,
							},
							"parent_scope_id": {
								Type:        schema.TypeString,
								Description: "Output only. The ID of the parent Scope, if any. This field will be empty if this is the \"global\" scope.",
								Computed:    true,
							},
							"type": {
								Type:        schema.TypeString,
								Description: "Output only. The type of the Scope.",
								Computed:    true,
							},
						},
					},
				},
				"scope_id": {
					Type:        schema.TypeString,
					Description: "The Scope of of this resource. This must be defined for creation of this resource, but is otherwise output only.",
					Computed:    true,
				},
				"session_connection_limit": {
					Type:        schema.TypeInt,
					Description: "Maximum number of connections allowed in a Session.  Unlimited is indicated by the value -1.",
					Computed:    true,
				},
				"session_max_seconds": {
					Type:        schema.TypeInt,
					Description: "Maximum total lifetime of a created Session, in seconds.",
					Computed:    true,
				},
				"type": {
					Type:        schema.TypeString,
					Description: "The type of the Target.",
					Computed:    true,
				},
				"updated_time": {
					Type:        schema.TypeString,
					Description: "Output only. The time this resource was last updated.",
					Computed:    true,
				},
				"version": {
					Type:        schema.TypeInt,
					Description: "Version is used in mutation requests, after the initial creation, to ensure this resource has not changed.\nThe mutation will fail if the version does not match the latest known good version.",
					Computed:    true,
				},
				"worker_filter": {
					Type:        schema.TypeString,
					Description: "Optional boolean expression to filter the workers that are allowed to satisfy this request.",
					Computed:    true,
				},
			},
		},
	},
	"recursive": {
		Type:     schema.TypeBool,
		Optional: true,
	},
	"scope_id": {
		Type:     schema.TypeString,
		Optional: true,
	},
}

func dataSourceTargets() *schema.Resource {
	return &schema.Resource{
		Description: "Lists all Targets.",
		Schema:      dataSourceTargetsSchema,
		ReadContext: dataSourceTargetsRead,
	}
}

func dataSourceTargetsRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*metaData).client

	req, err := client.NewRequest(ctx, "GET", "targets", nil)
	if err != nil {
		return diag.FromErr(err)
	}

	q := url.Values{}
	q.Add("filter", d.Get("filter").(string))
	recursive := d.Get("recursive").(bool)
	if recursive {
		q.Add("recursive", strconv.FormatBool(recursive))
	}
	q.Add("scope_id", d.Get("scope_id").(string))
	req.URL.RawQuery = q.Encode()

	resp, err := client.Do(req)
	if err != nil {
		diag.FromErr(err)
	}
	apiError, err := resp.Decode(nil)
	if err != nil {
		return diag.FromErr(err)
	}
	if apiError != nil {
		return apiErr(apiError)
	}
	err = set(dataSourceTargetsSchema, d, resp.Map)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId("boundary-targets")

	return nil
}
